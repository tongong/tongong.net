const m = require("lib/mithril");
const stream = require("lib/mithril-stream");
const sthelp = require("./modules/stream-helpers.js");

// size: number
//   size in pixels (screen not css)
// image: (x, y) -> pixel-value
//   0 <= x, y, < 1
//   transform a position in the image to a local state value like a color.
//   do not fluctuate locally (image and noise arguments are somewhat similar
//   to vertex and fragment shader)
// alternatively image can be an Image object. then pixel-value for the noise
//   function will be [r, g, b]
// noise: (x, y, pixel-value) -> [r, g, b]
//   0 <= r, g, b <= 255
//   take pixel coordinates and the value generated by image() and transform
//   them to rgb values
// update: stream
//   set zoom level by stream value
module.exports = () => {
    let sliderupdate;
    let zoom;
    return {
        oninit: (vnode) => {
            zoom = stream(1);
            sliderupdate = stream();
        },
        oncreate: (vnode) => {
            const canvas = vnode.dom.querySelector("canvas");
            const input_rough = vnode.dom.querySelector("input#rough")
            const input_fine = vnode.dom.querySelector("input#fine")

            input_rough.value = 1;
            input_fine.value = 0;

            sliderupdate.map(_ =>
                parseFloat(input_rough.value)
                + 0.01 * parseFloat(input_fine.value)
            ).map(val => zoom(Math.min(Math.max(val, 0), 2)));

            if (vnode.attrs.update) vnode.attrs.update.map(zoom);

            // only update sliders on external zoom set (sliders do not need to
            // update themselves)
            if (vnode.attrs.update) vnode.attrs.update.map(val => {
                input_rough.value = Math.round(val * 100) / 100;
                input_fine.value = (val - input_rough.value) * 100;
            });

            zoom.map(z => canvas.style.transform =
                "translate(-50%, -50%) scale(" + z + ")"
            );

            let SIZE = vnode.attrs.size;
            let SIZE_CSS = SIZE / window.devicePixelRatio;
            canvas.style.width = canvas.style.height = SIZE_CSS + "px";
            canvas.width = canvas.height = SIZE;

            const ctx = canvas.getContext("2d");
            let image_data;
            if (vnode.attrs.image instanceof HTMLImageElement) {
                ctx.drawImage(vnode.attrs.image, 0, 0);
                image_data = ctx.getImageData(0, 0, SIZE, SIZE);
            } else {
                image_data = ctx.createImageData(SIZE, SIZE);
            }
            for (let x = 0; x < SIZE; x++) {
                for (let y = 0; y < SIZE; y++) {
                    const pos = (y * SIZE + x) * 4;
                    let val;
                    if (vnode.attrs.image instanceof HTMLImageElement) {
                        val = image_data.data.slice(pos, pos + 3)
                    } else {
                        val = vnode.attrs.image(x / SIZE, y / SIZE);
                    }
                    [
                        image_data.data[pos],
                        image_data.data[pos + 1],
                        image_data.data[pos + 2],
                    ] = vnode.attrs.noise(x, y, val);
                    image_data.data[pos + 3] = 255;
                }
            }
            ctx.putImageData(image_data, 0, 0);
        },
        view: (vnode) => [
            m("div",
                m("div", { style: {
                    position: "relative",
                    overflow: "hidden",
                    lineHeight: 0,
                    width: "100%",
                    paddingBottom: "100%",
                }},
                    m("div", { style: {
                        position: "absolute",
                        width: "100%",
                        height: "100%",
                    }},
                        m("canvas", { style: {
                            position: "absolute",
                            top: "50%",
                            left: "50%",
                            transform: "",
                        }})
                    )
                ),
                m("p"),
                m("input#rough", {
                    type: "range",
                    min: 0,
                    max: 2,
                    step: 0.01,
                    oninput: () => sliderupdate(0),
                }),
                m("input#fine", {
                    type: "range",
                    min: -1,
                    max: 1,
                    step: 0.01,
                    oninput: () => sliderupdate(0),
                }),
                m("p", m("i",
                    vnode.attrs.size + "x" + vnode.attrs.size + " - " +
                    "Zoom: " + zoom().toFixed(4) + "x - ",
                    m("a", {
                        onclick: () => {
                            const canvas = vnode.dom.querySelector("canvas");
                            canvas.toBlob(blob => {
                                const url = URL.createObjectURL(blob);
                                window.open(url, '_blank');
                            });
                        }
                    }, "open image")
                )),
            ),
        ],
    };
};
